function overallMatrix = convert_mstm_tmatrix(fname)
% Read in T matrix generated by mstm and return data
% that corresponds to the T matrix in the shape and structure
% expected by ott.
% Inputs:
%      fname : (str) Name of T-matrix file output by mstm
% Outputs:
%      overallMatrix: (array, float) T-matrix in ott format

fileID = fopen(fname,'r'); 

line = 1;
tline = fgets(fileID); % reads top line from file, keeping newline
tline = str2num(tline);
sizeOfMatrix = tline(2);
subMatrixSize = (sizeOfMatrix^2) + (2 * sizeOfMatrix); % nmax^2 + 2nmax

% Allocate storage for data
% the order in which these quadrants are named is exactly as a cartesian grid
% [[II, I], [III, IV]]
firstQuad = zeros(subMatrixSize, subMatrixSize);
secondQuad = zeros(subMatrixSize, subMatrixSize);
thirdQuad = zeros(subMatrixSize, subMatrixSize);
fourthQuad = zeros(subMatrixSize, subMatrixSize);

% Constructing the overall matrix
tline = fgets(fileID); % Read line 2 of file
%disp(tline)

% Main loop over remaining lines of file, starting from 3
while ~feof(fileID)
  line = fgets(fileID); % Read next line
  numLine = str2num(line);
  
  if length(numLine) == 3 % Line is l, k, q
     l = numLine(1);
     nprime = l;
     k = numLine(2);
     mprime = k;
     q = numLine(3);
     colPosInSubMatrix = combined_index(nprime,mprime); %calculating column position
  elseif length(numLine) == 4 % line is scattering efficiency convergence checks
     % do nothing
  elseif length(numLine) == 6 % line has T matrix data
     n = numLine(1);
     m = numLine(2);
     rowPosInSubMatrix = combined_index(n,m);
     realPFirst = numLine(3); % p = 1
     imaginaryPFirst = numLine(4);
     realPSecond = numLine(5); % p = 2
     imaginaryPSecond = numLine(6);
     if q == 1 
         fourthQuad(rowPosInSubMatrix,colPosInSubMatrix) = realPFirst + imaginaryPFirst*i;
         firstQuad(rowPosInSubMatrix,colPosInSubMatrix) = realPSecond + imaginaryPSecond*i;
     else % q = 2
         thirdQuad(rowPosInSubMatrix,colPosInSubMatrix) = realPFirst +  imaginaryPFirst*i;
         secondQuad(rowPosInSubMatrix,colPosInSubMatrix) = realPSecond + imaginaryPSecond*i; 
     end  
  end
      
end

overallMatrix = [secondQuad, firstQuad ; thirdQuad, fourthQuad];

disp(overallMatrix)

fclose(fileID);

end


function [out1,out2] = combined_index(in1,in2)
%COMBINED_INDEX translates between (n,m) and combined index
% Mode indices and combined index are related by: ci = n * (n+1) + m.
%
% [n,m] = COMBINED_INDEX(ci) calculates (n,m) from the combined index.
%
% ci = COMBINED_INDEX(n,m) calculates the combined index from mode indices.
%
% length = COMBINED_INDEX(Nmax, Nmax) calculates length of the beam vectors.
%
% Nmax = COMBINED_INDEX(length) calculates Nmax from length of beam vectors.
%
% This file is part of the optical tweezers toolbox.
% See LICENSE.md for information about using/distributing this file.

% Sanity check
if nargin == 1
   out1 = floor(sqrt(in1));
   out2 = in1 - out1.^2 - out1;
elseif nargin == 2
   out1 = in1 .* (in1 + 1) + in2;
else
   error('Bad number of input/output arguments');
end
end
